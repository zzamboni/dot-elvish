:CONFIG:
#+property: header-args:elvish :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
#+property: header-args :mkdirp yes :comments no
#+startup: indent
:END:

#+title: My Elvish config file
#+author: Diego Zamboni
#+email: diego@zzamboni.org

This is my main config file for [[http://elv.sh][Elvish]].

This file is written in [[https://leanpub.com/lit-config][literate programming style]] using [[https://orgmode.org/][org-mode]]. See [[https://gitlab.com/zzamboni/dot-elvish/-/blob/master/rc.elv][rc.elv]] for the generated file. You can see this in a nicer format on my blog post [[http://zzamboni.org/post/my-elvish-configuration-with-commentary/][My Elvish Configuration With Commentary]].

* Table of Contents :TOC_3:noexport:
- [[#file-header][File header]]
- [[#module-loading][Module loading]]
- [[#paths][Paths]]
- [[#package-installation][Package installation]]
- [[#automatic-proxy-settings][Automatic proxy settings]]
- [[#general-modules-and-settings][General modules and settings]]
- [[#1password][1Password]]
- [[#aliases-and-miscellaneous-functions][Aliases and miscellaneous functions]]
- [[#completions][Completions]]
- [[#prompt-theme][Prompt theme]]
  - [[#starship][Starship]]
  - [[#chain][Chain]]
  - [[#other-prompt-settings][Other prompt settings]]
- [[#iterm2-shell-integration-support][iTerm2 shell integration support]]
- [[#long-running-command-notifications][Long-running-command notifications]]
- [[#directory-and-command-navigation-and-history][Directory and command navigation and history]]
- [[#dynamic-terminal-title][Dynamic terminal title]]
- [[#loading-private-settings][Loading private settings]]
- [[#oreilly-atlas][O'Reilly Atlas]]
- [[#opsgenie][OpsGenie]]
- [[#leanpub][LeanPub]]
- [[#tinytex][TinyTeX]]
- [[#conda-integration][Conda integration]]
- [[#pyenv][PyEnv]]
- [[#environment-variables][Environment variables]]
- [[#git-repository-summary][Git repository summary]]
- [[#utility-functions][Utility functions]]
- [[#work-specific-stuff][Work-specific stuff]]

* File header

A header to advise people who view the tangled file about where it comes from.

#+begin_src elvish :exports none
# DO NOT EDIT THIS FILE DIRECTLY
# This is a file generated from a literate programing source file located at
# https://gitlab.com/zzamboni/dot-elvish/-/blob/master/rc.org
# You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

* Module loading

Load a number of commonly-used modules so that they are available in my interactive session.

Load the bundled [[https://elv.sh/ref/re.html][re]] module to have access to regular expression functions.

#+begin_src elvish
use re
#+end_src

The bundled [[https://elv.sh/ref/readline-binding.html][readline-binding]] module associates some Emacs-like keybindings for manipulation of the command line.

#+begin_src elvish
use readline-binding
#+end_src

The bundled =path= module contains path manipulation functions.

#+begin_src elvish
use path
#+end_src

The bundled =str= and =math= modules for string manipulation and math operations.

#+begin_src elvish
use str
use math
#+end_src

Some code runs only if certain external binary exists, I define a couple of functions to help with this.

#+begin_src elvish
fn have-external { |prog|
  put ?(which $prog >/dev/null 2>&1)
}
fn only-when-external { |prog lambda|
  if (have-external $prog) { $lambda }
}
# Convert POSIX env assignments to Elvish
fn read-posix-envvars {
  each {|l|
    var _ key val = (re:split &max=3 '[ =]' $l)
    set val = (re:replace '^"' '' (re:replace '"$' '' $val))
    set-env $key $val
  }
}
#+end_src

* Paths

First we set up the executable paths. We set the =GOPATH= environment variable while we are at it, since we need to use it as part of the path.

#+begin_src elvish
# Where all the Go stuff is
#if (path:is-dir ~/Dropbox/Personal/devel/go) {
#  set E:GOPATH = ~/Dropbox/Personal/devel/go
#} else {
  set E:GOPATH = ~/go
#}
var brew-paths = []
only-when-external /home/linuxbrew/.linuxbrew/bin/brew {
  /home/linuxbrew/.linuxbrew/bin/brew shellenv | grep -v PATH | sed 's/;$//;' | read-posix-envvars
  set brew-paths = [$E:HOMEBREW_PREFIX/bin $E:HOMEBREW_PREFIX/sbin]
}

# Optional paths, add only those that exist
var optpaths = [
  $E:GOPATH/bin
  $@brew-paths
  ~/bin/(uname -s | tr '[:upper:]' '[:lower:]')-(uname -m)
  ~/.emacs.d/bin
  /usr/local/opt/coreutils/libexec/gnubin
  /usr/local/opt/texinfo/bin
  /usr/local/opt/python/libexec/bin
  /usr/local/go/bin
  /snap/bin
  ~/Work/automated-security-helper
  ~/.toolbox/bin
  ~/.local/bin
  ~/.local/share/omakub/bin
]
var optpaths-filtered = [(each {|p|
      if (path:is-dir $p) { put $p }
} $optpaths)]

set paths = [
  ~/bin
  $@optpaths-filtered
  /usr/local/bin
  /usr/local/sbin
  /usr/sbin
  /sbin
  /usr/bin
  /bin
]
#+end_src

My work machine setup blocks =proxy.golang.org=, so I configure for all modules to be downloaded directly from their source.

#+begin_src elvish
set E:GONOPROXY = "*"
#+end_src

I have a quick sanity check because sometimes certain paths disappear depending on new versions, etc. This prints a warning when opening a new shell, if there are any non-existing directories in =$paths=. We need some wrapping around =path:eval-symlinks= to avoid seeing warnings when the directory does not exist.

#+begin_src elvish
each {|p|
  if (not (path:is-dir &follow-symlink $p)) {
    echo (styled "Warning: directory "$p" in $paths no longer exists." red)
  }
} $paths
#+end_src
* Package installation

The bundled [[https://elv.sh/ref/epm.html][epm]] module allows us to install and manage Elvish packages.

#+begin_src elvish
use epm
#+end_src

For now I use these packages:

- [[https://github.com/zzamboni/elvish-modules][github.com/zzamboni/elvish-modules]] contains all my modules except completions and themes. Maybe these should be separated eventually, but for now this works fine.
- [[https://github.com/zzamboni/elvish-themes][github.com/zzamboni/elvish-themes]] contains my prompt themes (only [[https://github.com/zzamboni/elvish-themes/blob/master/chain.org][chain]] for now).
- [[https://github.com/zzamboni/elvish-completions][github.com/zzamboni/elvish-completions]] contains my completer definitions.
- [[https://github.com/xiaq/edit.elv][github.com/xiaq/edit.elv]], which includes the =smart-matcher= module used below.
- [[https://github.com/muesli/elvish-libs][github.com/muesli/elvish-libs]] for the git utilities module.
- [[https://github.com/iwoloschin/elvish-packages][github.com/iwoloschin/elvish-packages]] for the update.elv package.

#+begin_src elvish
epm:install &silent-if-installed         ^
github.com/zzamboni/elvish-modules     ^
github.com/zzamboni/elvish-completions ^
github.com/xiaq/edit.elv               ^
github.com/muesli/elvish-libs
# github.com/iwoloschin/elvish-packages
#+end_src

The modules within each package get loaded individually below.

* Automatic proxy settings

When I am in the office, I need to use a proxy to access the Internet. For macOS applications, the proxy is set automatically using a company-provided PAC file. For the environment variables =http_proxy= and =https_proxy=, commonly used by command-line programs, the [[https://github.com/zzamboni/modules.elv/blob/master/proxy.org][proxy]] module allows me to define a test which determines when the proxy should be used, so that the change is done automatically. We load this early on so that other modules which need to access the network get the correct settings already.

First, we load the module and set the proxy host.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/proxy
set proxy:host = "http://aproxy.corproot.net:8080"
#+end_src

Next, we set the test function to enable proxy auto-setting. In my case, the =/etc/resolv.conf= file contains the =corproot.net= domain (set through DHCP) when I'm in the corporate network, so I can check for that.

#+begin_src elvish :exports none
set proxy:test = {
  and ?(test -f /etc/resolv.conf) ^
  ?(egrep -q '^(search|domain).*(corproot.net|swissptt.ch)' /etc/resolv.conf)
}
#+end_src

#+begin_src elvish :tangle no
proxy:test = {
  and ?(test -f /etc/resolv.conf) ^
  ?(egrep -q '^(search|domain).*(corproot.net|company.com)' /etc/resolv.conf)
}
#+end_src

We run an initial check so that other commands in rc.org get the correctd settings already, even before the first prompt.

#+begin_src elvish
proxy:autoset
#+end_src

* General modules and settings

I add a couple of keybindings which are missing from the default =readline-binding= module:

- =Alt-backspace= to delete small-word

  #+begin_src elvish
  set edit:insert:binding[Alt-Backspace] = $edit:kill-small-word-left~
  #+end_src

- =Alt-d= to delete the small-word under the cursor

  #+begin_src elvish
  set edit:insert:binding[Alt-d] = $edit:kill-small-word-right~
  #+end_src

- I also bind "[[https://elv.sh/ref/edit.html#edit-instantstart][instant preview mode]]" to ~Alt-m~. This is useful to see the results of a command while you are typing it.

  #+begin_src elvish
  set edit:insert:binding[Alt-m] = $edit:-instant:start~
  #+end_src

- Limit the height of location and history mode so that they don't cover the whole screen.

  #+begin_src elvish
  set edit:max-height = 20
  #+end_src

* 1Password

My =1pass= module provides some wrappers for interacting with the [[https://support.1password.com/command-line/][1Password command line utility]].

#+begin_src elvish
use github.com/zzamboni/elvish-modules/1pass
#+end_src

Read aliases defined by the =op plugin= command. See https://blog.1password.com/shell-plugins/ for more details about  =op= shell plugins.

#+begin_src elvish
1pass:read-aliases
#+end_src

I haven't gotten around to write an =op= plugin for this, so I still use my =lazy-vars= module to read the credentials for my [[https://github.com/zzamboni/750words-client][750words command-line client]].

#+begin_src elvish
use github.com/zzamboni/elvish-modules/lazy-vars

set E:USER_750WORDS = diego@zzamboni.org
lazy-vars:add-var PASS_750WORDS { 1pass:get-password "750words.com" }
lazy-vars:add-alias 750words-client.py [ PASS_750WORDS ]
#+end_src

* Aliases and miscellaneous functions

Elvish does not have built-in alias functionality, but this is implemented easily using the [[https://github.com/zzamboni/modules.elv/blob/master/alias.org][alias]] module, which stores the alias definitions as functions under [[https://github.com/zzamboni/dot-elvish/tree/master/aliases][~/.elvish/aliases/]] and loads them automatically.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/alias
#+end_src

For reference, I define here a few of my commonly-used aliases.

#+begin_src elvish
only-when-external dfc {
  alias:new dfc e:dfc -p -/dev/disk1s4,devfs,map,com.apple.TimeMachine
}
only-when-external vagrant {
  alias:new v vagrant
}
only-when-external hub {
  alias:new git hub
}
#+end_src

Use =bat= as my default pager, if installed.

#+begin_src elvish
only-when-external bat {
  alias:new cat bat
  alias:new more bat --paging always
  #set E:MANPAGER = "sh -c 'col -bx | bat -l man -p'"
}
only-when-external batcat {
  alias:new cat batcat
  alias:new more batcat --paging always
  #set E:MANPAGER = "sh -c 'col -bx | batcat -l man -p'"
}
#+end_src

If available, use the scripts from =bat-extras= to replace some other commands, like =man=.

#+begin_src elvish
only-when-external batman {
  alias:new man batman
}
only-when-external batgrep {
  alias:new rg batgrep
}
only-when-external batdiff {
  alias:new diff batdiff
}
#+end_src
Open man pages as PDF, I gathered this tip from https://twitter.com/MrAhmadAwais/status/1279066968981635075. Neat but not very useful for daily use, particularly with the =bat= integration above.

#+begin_src elvish
fn manpdf {|@cmds|
  each {|c|
    man -t $c | open -f -a /System/Applications/Preview.app
  } $cmds
}
#+end_src

#+begin_src elvish
only-when-external fdfind {
  alias:new fd fdfind
}
#+end_src
* Completions

The [[https://github.com/xiaq/edit.elv/blob/master/smart-matcher.elv][smart-matcher]] module tries prefix match, smart-case prefix match, substring match, smart-case substring match, subsequence match and smart-case subsequence match automatically.

#+begin_src elvish
use github.com/xiaq/edit.elv/smart-matcher
smart-matcher:apply
#+end_src

Other possible values for =edit:completion:matcher= are =[p]{ edit:match-prefix &smart-case $p }= for smart-case completion (if your pattern is entirely lower case it ignores case, otherwise it's case sensitive).  =&smart-case= can be replaced with =&ignore-case= to make it always case-insensitive.

I now use the universal Carapace completer module for most commends instead of custom-built Elvish completions:

#+begin_src elvish
# Enable the universal command completer if available.
# See https://github.com/rsteube/carapace-bin
if (has-external carapace) {
  eval (carapace _carapace | slurp)
}
#+end_src

One exception is the =ssh= completer, I like my custom version from the  [[https://github.com/zzamboni/elvish-completions][elvish-completions]] package better, because it completes hostnames from =~/.ssh/config= instead of from =~/.ssh/known_hosts=.

#+begin_src elvish
use github.com/zzamboni/elvish-completions/ssh
#+end_src

* Prompt theme

** Starship

I now use  [[https://starship.rs/][Starship]] for my prompt.

#+begin_src elvish
#   eval (starship init elvish | sed 's/except/catch/')
# Temporary fix for use of except in the output of the Starship init code
eval (starship init elvish --print-full-init | slurp)
#+end_src

You can find my current Starship config file at [[https://gitlab.com/zzamboni/mac-setup/-/blob/master/files/homefiles/.config/starship.toml]].

** Chain

I developed the [[https://github.com/zzamboni/theme.elv/blob/master/chain.org][chain]] prompt theme, ported from the fish theme at https://github.com/oh-my-fish/theme-chain. This whole section is disabled since I switched to [[https://starship.rs/][Starship]], but left here for reference.

#+begin_src elvish :tangle no
epm:install &silent-if-installed github.com/zzamboni/elvish-themes
use github.com/zzamboni/elvish-themes/chain
chain:bold-prompt = $false
#+end_src

I set the color of the directory segment, the prompt chains and the prompt arrow in my prompt to a session-identifying color (a different color for each session).

#+begin_src elvish :tangle no
chain:segment-style = [
  &dir=          session
  &chain=        session
  &arrow=        session
  &git-combined= session
  &git-repo=     bright-blue
]
#+end_src

Customize some of the glyphs for the font I use in my terminal. I use the [[https://github.com/tonsky/FiraCode][Fira Code]] font which includes ligatures, so I disable the last chain, and set the =arrow= segment to a combination of characters which shows up as a nice arrow.

#+begin_src elvish :tangle no
chain:glyph[arrow]  = "|>"
chain:show-last-chain = $false
#+end_src

** Other prompt settings

Elvish has a [[https://elv.sh/ref/edit.html#prompts][comprehensive mechanism]] for displaying prompts with useful information while avoiding getting blocked by prompt functions which take too long to finish. For the most part the defaults work well. One change I like to make is to change the [[https://elv.sh/ref/edit.html#stale-prompt][stale prompt transformer]] function to make the prompt dim when stale (the default is to show the prompt in inverse video):

#+begin_src elvish
set edit:prompt-stale-transform = {|x| styled $x "bright-black" }
#+end_src

Another possibility is to make the prompt stay the same when stale - useful to avoid distractions (disabled for now):

#+begin_src elvish :tangle no
#  edit:prompt-stale-transform = $all~
#+end_src

I also like the continuous update of the prompt as I type (by default it only updates on Enter and on =$pwd= changes, but I like also git status changes to be updated automatically), so I increase its eagerness.

#+begin_src elvish
set edit:-prompt-eagerness = 10
#+end_src

* iTerm2 shell integration support

The =iterm2= module provides support for iTerm2's [[https://iterm2.com/documentation-shell-integration.html][Shell Integration]] features. Note that =iterm2:init= must be called after setting up the prompt, hence this is done after loading the =chain= module above.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/iterm2
iterm2:init
set edit:insert:binding[Ctrl-L] = $iterm2:clear-screen~
#+end_src

* Long-running-command notifications

The [[https://github.com/zzamboni/modules.elv/blob/master/long-running-notifications.org][long-running-notifications]] module allows for producing a notification when a command takes longer than a certain time to finish (by default the period is 10 seconds). The module automatically detects when [[https://github.com/julienXX/terminal-notifier][terminal-notifier]] is available on macOS and uses it to produce Mac-style notifications, otherwise it prints a notification on the terminal.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/long-running-notifications
#+end_src

* Directory and command navigation and history

Elvish comes with built-in location and command history modes, and these are the main mechanism for accessing prior directories and commands. The weight-keeping in location mode makes the most-used directories automatically raise to the top of the list over time.

I have decades of muscle memory using ~!!~ and ~!$~ to insert the last command and its last argument, respectively. The [[https://github.com/zzamboni/elvish-modules/blob/master/bang-bang.org][bang-bang]] module allows me to keep using them.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/bang-bang
#+end_src

The [[https://github.com/zzamboni/modules.elv/blob/master/dir.org][dir]] module implements a directory history and some related functions. I alias the =cd= command to =dir:cd= so that any directory changes are kept in the history. I also alias =cdb= to =dir:cdb= function, which allows changing to the base directory of the argument.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/dir
alias:new cd &use=[github.com/zzamboni/elvish-modules/dir] dir:cd
alias:new cdb &use=[github.com/zzamboni/elvish-modules/dir] dir:cdb
#+end_src

=dir= also implements a custom directory history chooser, which I bind to ~Alt-i~ (I have found I don't use this as much as I thought I would - the built-in location mode works nicely).

#+begin_src elvish
set edit:insert:binding[Alt-i] = $dir:history-chooser~
#+end_src

I bind =Alt-b/f= to =dir:left-small-word-or-prev-dir= and =dir:right-small-word-or-next-dir= respectively, which "do the right thing" depending on the current content of the command prompt: if it's empty, they move back/forward in the directory history, otherwise they move through the words of the current command. In my terminal setup, =Alt-left/right= also produce =Alt-b/f=, so these bindings work for those keys as well.

#+begin_src elvish
set edit:insert:binding[Alt-b] = $dir:left-small-word-or-prev-dir~
set edit:insert:binding[Alt-f] = $dir:right-small-word-or-next-dir~
#+end_src

If =fzf= is installed, then we can have a fancier history search instead of the default bound to =Ctrl-R=.

#+begin_src elvish
# Filter the command history through the fzf program. This is normally bound
# to Ctrl-R.
fn fzf_history {
  var new-cmd = (
    edit:command-history &dedup &newest-first &cmd-only |
    to-terminated "\x00" |
    try {
      fzf --no-sort --read0 --info=hidden --exact ^
      --query=$edit:current-command
    } catch {
      # If the user presses [Escape] to cancel the fzf operation it will exit
      # with a non-zero status. Ignore that we ran this function in that case.
      return
    }
  )
  set edit:current-command = $new-cmd
}

only-when-external fzf {
  set edit:insert:binding[Ctrl-R] = { fzf_history >/dev/tty 2>&1 }
}
#+end_src

I use [[https://github.com/eza-community/eza][eza]] as a replacement for the =ls= command, so I alias =ls= to it. Unfortunately, =eza= does not understand the =-t= option to sort files by modification time, so I explicitly look for the =-lrt= and =-lrta= option combinations (which I use very often, and /always/ trip me off) and replace them with the correct options for =eza=. All other options are passed as-is.

#+begin_src elvish
only-when-external eza {
  var eza-ls~ = { |@_args|
    use github.com/zzamboni/elvish-modules/util
    e:eza --color-scale --git --group-directories-first --header --group-directories-first --icons=auto (each {|o|
        util:cond [
          { eq $o "-lrt" }  "-lsnew"
          { eq $o "-lrta" } "-alsnew"
          :else             $o
        ]
    } $_args)
  }
  edit:add-var ls~ $eza-ls~
  alias:new lt eza --tree --level=2 --long --icons --git
}
#+end_src
* Dynamic terminal title

The [[https://github.com/zzamboni/elvish-modules/blob/master/terminal-title.org][terminal-title]] module handles setting the terminal title dynamically according to the current directory or the current command being executed.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/terminal-title
#+end_src

* Loading private settings

The =private= module sets up some private settings such as authentication tokens. This is not on github :) The =$private-loaded= variable gets set to =$ok= if the module was loaded correctly.

#+begin_src elvish
var private-loaded = ?(use private)
#+end_src

* O'Reilly Atlas

I sometimes use the [[https://atlas.oreilly.com/][O'Reilly Atlas]] publishing platform. The [[https://github.com/zzamboni/modules.elv/blob/master/atlas.org][atlas]] module contains some useful functions for triggering and accessing document builds.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/atlas
#+end_src

* OpsGenie

I used OpsGenie at work for a while, so I put together the [[https://github.com/zzamboni/elvish-modules/blob/master/opsgenie.org][opsgenie]] library to make API operations easier. I don't actively use or maintain this anymore.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/opsgenie
#+end_src

* LeanPub

I use [[https://leanpub.com/help/api][LeanPub]] for publishing my books, so I have written a few utility functions. I don't use this regularly, I have much better integration using Hammerspoon and CircleCI, I wrote about it in my blog: [[https://zzamboni.org/post/automating-leanpub-book-publishing-with-hammerspoon-and-circleci/][Automating Leanpub book publishing with Hammerspoon and CircleCI]]. The Leanpub API key is fetched from 1Password when needed.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/leanpub
set leanpub:api-key-fn = { 1pass:get-item leanpub &fields=["API key"] }
#+end_src

* TinyTeX

Tiny module with some utility functions for using [[https://yihui.org/tinytex/][TinyTeX]].

#+begin_src elvish
use github.com/zzamboni/elvish-modules/tinytex
#+end_src

* Conda integration

Conda integration for Elvish. This is not yet in the main Conda distribution, but in a PR: https://github.com/conda/conda/pull/10731

The following block will get added to =rc.elv= by =conda init elvish=. Having it tangled out allows me to control where in the file it appears, since Conda only replaces/updates it instead of adding it again.

#+begin_src elvish :tangle no
if (path:is-dir ~/Dropbox/Personal/devel/conda/devenv/bin) {
  set @paths = ~/Dropbox/Personal/devel/conda/devenv/bin $@paths
}
only-when-external conda {
  conda config --set auto_activate_base false
  # >>> conda initialize >>>
  # !! Contents within this block are managed by 'conda init' !!
  eval (~/Dropbox/Personal/devel/conda/devenv/bin/conda "shell.elvish" "hook" | upgrade-scripts-for-0.17 -lambda | slurp)"; conda activate aws"
  # <<< conda initialize <<<
}
#+end_src

I can configure Conda to deactivate itself, or to set a default environment, through some files in my home directory.

#+begin_src elvish :tangle no
conda-deactivate = ~/.conda-deactivate
conda-default-env = ~/.conda-default-env

if (path:is-regular $conda-deactivate) {
  conda deactivate
} else {
  if (path:is-regular $conda-default-env) {
    conda activate (cat $conda-default-env)
  }
}
#+end_src
* PyEnv

I do some manual setup for [[https://github.com/pyenv/pyenv][PyEnv]], since it does not yet have built-in support for Elvish.

#+begin_src elvish
only-when-external pyenv {
  set paths = [ ~/.pyenv/shims $@paths ]
  set-env PYENV_SHELL elvish
}
#+end_src

* Environment variables

Default options to =less=.

#+begin_src elvish
set E:LESS = "-i -R"
#+end_src

Use vim as the editor from the command line (although I am an [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][Emacs]] fan, I still sometimes use vim for quick editing).

#+begin_src elvish
set E:EDITOR = "vim"
#+end_src

Locale setting.

#+begin_src elvish
set E:LC_ALL = "en_US.UTF-8"
#+end_src

=PKG_CONFIG= configuration.

#+begin_src elvish
set E:PKG_CONFIG_PATH = "/usr/local/opt/icu4c/lib/pkgconfig"
#+end_src

* Git repository summary

The =git-summary= module allows displaying the git status of multiple repositories in a single list. I use it to keep track of the status of my commonly-used repos. I load the module as =gs= to make it easier to call its functions.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/git-summary gs
#+end_src

Stop =gitstatusd= from staying in the background, since it's only used for this purpose.

#+begin_src elvish
set gs:stop-gitstatusd-after-use = $true
#+end_src

Customize the command used for finding git repos for =git-summary:summary-status &all=, to ignore some uninteresting repos. List of directories to exclude is defined in =$git-summary-repos-to-exclude=.

#+begin_src elvish
var git-summary-repos-to-exclude = ['.emacs.d*' .cargo Library/Caches Dropbox/Personal/devel/go/src]
var git-summary-fd-exclude-opts = [(each {|d| put -E $d } $git-summary-repos-to-exclude)]
set gs:find-all-user-repos-fn = {
  fd -H -I -t d $@git-summary-fd-exclude-opts '^.git$' ~ | each $path:dir~
}
#+end_src
* Utility functions

The [[https://github.com/zzamboni/elvish-modules/blob/master/util.org][util]] module includes various utility functions.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/util
#+end_src

I use muesli's git utilities module.

#+begin_src elvish
use github.com/muesli/elvish-libs/git
#+end_src

The [[https://github.com/iwoloschin/elvish-packages/blob/master/update.elv][update.elv]] package prints a message if there are new commits in Elvish after the running version.

#+begin_src elvish :tangle no
use github.com/iwoloschin/elvish-packages/update
set update:curl-timeout = 3
update:check-commit &verbose
#+end_src

Set up electric delimiters in the command line.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/util-edit
util-edit:electric-delimiters
#+end_src

ASCII spinners and TTY escape code generation.

#+begin_src elvish
use github.com/zzamboni/elvish-modules/spinners
use github.com/zzamboni/elvish-modules/tty
#+end_src

* Work-specific stuff

I have a private library which contains some work-specific functions.

#+begin_src elvish :tangle no
use work
#+end_src
